---
import ImageLoader from './ImageLoader';
import blurHashData from '../data/blurhash.json';
import { blurHashToGradient } from '../utils/blurhashToGradient';

export interface Props {
  src: string | { src: string; [key: string]: unknown };
  alt: string;
  slug?: string;
  width?: number;
  height?: number;
  widths?: number[];
  sizes?: string;
  quality?: number;
  format?: 'webp' | 'avif' | 'png' | 'jpg';
}

const { 
  src, 
  alt, 
  width = 800, 
  // widths = [400, 600, 800, 1200], // Astro Image 컴포넌트를 사용하지 않으므로 주석 처리
  sizes = "(max-width: 600px) 400px, (max-width: 900px) 600px, 800px",
  // quality = 80, // Astro Image 컴포넌트를 사용하지 않으므로 주석 처리
  // format = 'webp' // Astro Image 컴포넌트를 사용하지 않으므로 주석 처리
} = Astro.props;

let { height } = Astro.props;

// URL에서 slug 추출
const urlPath = Astro.url.pathname;
const slugMatch = urlPath.match(/\/blog\/([^/]+)/);
const slug = slugMatch ? slugMatch[1] : undefined;

// src가 객체인지 문자열인지 확인하고 적절한 값 추출
const imageSrc = typeof src === "object" ? src.src : src;

// 고유한 이미지 ID 생성
const imageId = `img-${Math.random().toString(36).substr(2, 9)}`;

// 모든 content/blog 이미지들을 동적으로 import
const images = import.meta.glob('/src/content/blog/**/*.{jpg,jpeg,png,webp,gif,svg}');

// 실제 이미지 처리를 위한 변수
let imageElement;
let useAstroImage = false;

if (slug && imageSrc && imageSrc.startsWith('./')) {
  // 상대 경로인 경우 절대 경로로 변환
  const absolutePath = `/src/content/blog/${slug}/${imageSrc.replace('./', '')}`;
  
  if (images[absolutePath]) {
    try {
      // dynamic import로 이미지 로드
      const imageModule = await images[absolutePath]();
      const imageSrcResolved = (imageModule as { default?: { src: string } })?.default?.src || (imageModule as { src: string })?.src;
      
      if (imageSrcResolved) {
        imageElement = (
          <img
            id={imageId}
            src={imageSrcResolved}
            alt={alt}
            loading="lazy"
            width={width}
            height={height}
            sizes={sizes}
            style="position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; margin: 0; padding: 0; border: 0;"
          />
        );
        useAstroImage = true;
      }
    } catch (error) {
      console.error("이미지 로드 오류:", error);
    }
  }
}

if (!useAstroImage) {
  imageElement = (
    <img
      id={imageId}
      src={imageSrc}
      alt={alt}
      loading="lazy"
      width={width}
      height={height}
      style="position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; margin: 0; padding: 0; border: 0;"
    />
  );
}

// BlurHash 데이터 처리
const normalizeImagePath = (path: string, slug: string): string => {
  // /@fs/absolute/path/src/content/blog/... -> blog/...
  const fsMatch = path.match(/\/@fs.*?\/src\/content\/(blog\/.+?)(\?|$)/);
  if (fsMatch) {
    return fsMatch[1];
  }

  // 일반적인 상대 경로 처리
  if (path.startsWith("./")) {
    const cleanSrc = path.replace(/^\.\//, "");
    return `blog/${slug}/${cleanSrc}`;
  }

  // 이미 blog/로 시작하는 경우
  if (path.startsWith("blog/")) {
    return path;
  }

  return path;
};

// BlurHash 데이터 타입 정의
type BlurHashEntry = {
  hash: string;
  width: number;
  height: number;
};

type BlurHashData = Record<string, BlurHashEntry | undefined>;

let gradientStyle = 'linear-gradient(135deg, #f5f5f5 0%, #eeeeee 100%)';
let aspectRatio = 'auto';

if (slug && imageSrc) {
  const imagePath = normalizeImagePath(imageSrc, slug);
  const imageData = (blurHashData as BlurHashData)[imagePath];
  
  if (imageData) {
    try {
      gradientStyle = blurHashToGradient(imageData.hash);
      aspectRatio = (imageData.width / imageData.height).toString();
      
      if (!height && imageData.height && imageData.width) {
        height = Math.round(width * (imageData.height / imageData.width));
      }
    } catch (error) {
      console.error("BlurHash 디코딩 오류:", error);
    }
  }
}

// 디버깅을 위한 로그
if (slug && imageSrc) {
  const imagePath = normalizeImagePath(imageSrc, slug);
  const hasBlurHash = !!(blurHashData as BlurHashData)[imagePath];
  console.log('[BlogImageWrapper] Image:', imagePath, 'HasBlurHash:', hasBlurHash, 'GradientStyle:', gradientStyle);
}
---

<div
  class="blog-image-wrapper"
  style={`position: relative; width: 100%; overflow: hidden; border-radius: 1rem;`}
>
  <!-- aspect-ratio를 보존하기 위한 wrapper -->
  <div 
    class="aspect-ratio-wrapper"
    style={`width: 100%; padding-bottom: ${aspectRatio !== 'auto' ? `${(1 / parseFloat(aspectRatio)) * 100}%` : '56.25%'}; position: relative; background: ${gradientStyle};`}
  >
    <!-- 그라데이션 placeholder (서버사이드 렌더링) -->
    <div
      class="gradient-placeholder"
      style={`background: ${gradientStyle}; position: absolute; inset: 0; transition: opacity 0.3s ease; opacity: 1;`}
    ></div>

    {imageElement}
  </div>

  <!-- 이미지 로딩 로직만 클라이언트사이드에서 처리 -->
  <ImageLoader 
    client:only="react"
    imageId={imageId}
    imageSrc={imageSrc}
  />
</div>

<style>
  .blog-image-wrapper {
    contain: layout style;
  }
  
  .aspect-ratio-wrapper {
    will-change: auto;
  }
  
  .gradient-placeholder {
    will-change: opacity;
  }
  
  /* 프린트 시 placeholder 숨김 */
  @media print {
    .gradient-placeholder {
      display: none;
    }
  }
</style>
