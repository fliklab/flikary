<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>BlurHash Preview Comparison</title>
  <script type="module" src="https://cdn.jsdelivr.net/npm/blurhash@2.0.5/+esm"></script>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 1rem; }
    .row { display: flex; justify-content: center; gap: 1rem; margin-bottom: 2rem; flex-wrap: wrap; }
    .block { display: flex; flex-direction: column; align-items: center; }
    canvas, img {
      border: 1px solid #ccc;
      transition: opacity 0.3s ease;
      cursor: pointer;
    }
    
    /* ì›ë³¸ ì´ë¯¸ì§€ëŠ” JavaScriptì—ì„œ ì„¤ì •í•œ í¬ê¸°ë¡œ í‘œì‹œ */
    #originalImage {
      /* ìµœëŒ€ í¬ê¸° ì œí•œ ì œê±° - JavaScriptì—ì„œ ì„¤ì •í•œ í¬ê¸° ì‚¬ìš© */
    }
    
    /* ìº”ë²„ìŠ¤ë“¤ì€ JavaScriptì—ì„œ ì„¤ì •í•œ í¬ê¸°ë¡œ í‘œì‹œ */
    canvas {
      /* ìµœëŒ€ í¬ê¸° ì œí•œ ì œê±° - JavaScriptì—ì„œ ì„¤ì •í•œ í¬ê¸° ì‚¬ìš© */
    }
    .comparison-container {
      position: relative;
      display: inline-block;
    }
    .original-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 10;
    }
    .comparison-container:hover .original-overlay {
      opacity: 1;
    }
    .data-output {
      background: #f5f5f5;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 8px;
      font-family: monospace;
      text-align: left;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .instruction {
      background: #e3f2fd;
      padding: 0.5rem;
      margin: 1rem 0;
      border-radius: 4px;
      font-size: 0.9rem;
      color: #1976d2;
    }
    .controls {
      background: #f5f5f5;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 8px;
      display: flex;
      gap: 2rem;
      flex-wrap: wrap;
      align-items: center;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
    }
    .controls input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }
    .explanation {
      background: #fff3cd;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 8px;
      border-left: 4px solid #ffc107;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .gradient-point {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 4px rgba(0,0,0,0.8);
      z-index: 25;
      pointer-events: none;
    }
    .position-marker {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 0 4px rgba(0,0,0,0.5);
      z-index: 20;
      pointer-events: none;
    }
    .position-marker.corner {
      background: #ff6b6b;
    }
    .position-marker.dominant {
      background: #4ecdc4;
    }
    .position-marker.dominant.color1 {
      background: #ff6b6b;
    }
    .position-marker.dominant.color2 {
      background: #4ecdc4;
    }
    .position-marker.dominant.color3 {
      background: #45b7d1;
    }
    .position-marker.dominant.color4 {
      background: #96ceb4;
    }
    .position-marker.dominant.color5 {
      background: #feca57;
    }
    .position-label {
      position: absolute;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      z-index: 30;
      pointer-events: none;
      transform: translateY(-20px);
    }
  </style>
</head>
<body>
  <h1>ğŸ§ª ì´ë¯¸ì§€ í‘œí˜„ ë¹„êµ</h1>
  <input type="file" id="imageInput" accept="image/*" />
  
  <div class="controls">
    <label><input type="checkbox" id="showOriginalMarkers" checked> ì›ë³¸ ì´ë¯¸ì§€ì— ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ</label>
    <label><input type="checkbox" id="showGradientPoints" checked> ê²°ê³¼ ì´ë¯¸ì§€ì— ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€ì  í‘œì‹œ</label>
    <label><input type="checkbox" id="showExplanation" checked> ê·¸ë¼ë””ì–¸íŠ¸ í•´ì„¤ í‘œì‹œ</label>
  </div>
  
      <div class="instruction">
      ğŸ’¡ ê° ì˜ˆì‹œì— ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ì›ë³¸ ì´ë¯¸ì§€ê°€ í‘œì‹œë˜ì–´ ë¹„êµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
      ğŸ”´ ë¹¨ê°„ ì : 4ì½”ë„ˆ ìƒ‰ìƒ ì¶”ì¶œ ìœ„ì¹˜ | ğŸ”µ íŒŒë€ ì : ëŒ€í‘œ ìƒ‰ìƒ ì¶”ì¶œ ìœ„ì¹˜ (5ê°œ ìƒ‰ìƒ Ã— 3ê°œ ìœ„ì¹˜)<br>
      ğŸ¨ ìƒ‰ìƒë³„ ë§ˆì»¤: ê° ëŒ€í‘œ ìƒ‰ìƒì˜ ì‹¤ì œ ì¶”ì¶œ ìœ„ì¹˜ì™€ ìƒ‰ìƒ ì •ë³´<br>
      ğŸ“Š ì •ë³´ì°½: â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ì˜ ì¶”ì¶œ í†µê³„ ì •ë³´
    </div>

  <div class="row" id="row1">
    <div class="block">
      <div class="comparison-container">
        <img id="originalImage1">
        <img class="original-overlay" id="originalOverlay1">
        <div id="positionMarkers1"></div>
  </div>
      <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
  </div>
  </div>
  
  <!-- BlurHash 2ë‹¨ê³„ -->
  <div class="row">
    <div class="block">
        <div class="comparison-container">
          <img id="originalImage2">
          <img class="original-overlay" id="originalOverlay2">
          <div id="positionMarkers2"></div>
  </div>
        <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="blurhash32Canvas"></canvas>
        <img class="original-overlay" id="originalOverlay2a">
      </div>
      <p>â‘¡ BlurHash - 32í”½ì…€ ì´ë¯¸ì§€</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="blurhashCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay2b">
        <div id="gradientPoints2"></div>
      </div>
      <p>â‘¡ BlurHash - ìµœì¢… ì´ë¯¸ì§€</p>
      <div id="explanation2" class="explanation" style="display: none;">
        <strong>â‘¡ BlurHash í•´ì„¤:</strong><br>
        â€¢ 1ë‹¨ê³„: 32Ã—32 í”½ì…€ë¡œ ì¶•ì†Œí•˜ì—¬ ì£¼íŒŒìˆ˜ ë¶„ì„<br>
        â€¢ 2ë‹¨ê³„: BlurHash ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ 4Ã—4 DCT ê¸°ë°˜ ê·¸ë¼ë””ì–¸íŠ¸ ìƒì„±<br>
        â€¢ íŠ¹ì§•: ì••ì¶•ëœ í•´ì‹œ ë¬¸ìì—´ë¡œ ì´ë¯¸ì§€ì˜ ì£¼íŒŒìˆ˜ ì •ë³´ë¥¼ ì €ì¥
      </div>
    </div>
  </div>
  
  <!-- 2Ã—2 ë¸”ëŸ¬ 2ë‹¨ê³„ -->
  <div class="row">
    <div class="block">
        <div class="comparison-container">
          <img id="originalImage3">
          <img class="original-overlay" id="originalOverlay3">
          <div id="positionMarkers3"></div>
        </div>
        <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="fourPixelCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay3a">
        <div id="gradientPoints3a"></div>
      </div>
      <p>â‘¢ 4í”½ì…€ ë¸”ëŸ¬ - í”½ì…€ ì´ë¯¸ì§€ (2Ã—2)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="fourPixelBlurCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay3b">
        <div id="gradientPoints3b"></div>
      </div>
      <p>â‘¢ 4í”½ì…€ ë¸”ëŸ¬ - ìµœì¢… ì´ë¯¸ì§€ (2Ã—2 + Blur)</p>
      <div id="explanation3" class="explanation" style="display: none;">
        <strong>â‘¢ 4í”½ì…€ ë¸”ëŸ¬ í•´ì„¤:</strong><br>
        â€¢ ì™¼ìª½: 4ê°œ ì½”ë„ˆ ìƒ‰ìƒì„ 2Ã—2 ê·¸ë¦¬ë“œë¡œ ì§ì ‘ ë°°ì¹˜<br>
        â€¢ ì˜¤ë¥¸ìª½: 2Ã—2 í”½ì…€ ì´ë¯¸ì§€ì— Blur íš¨ê³¼ ì ìš©<br>
        â€¢ êµ¬ì„±: TopLeft, TopRight, BottomLeft, BottomRight ìƒ‰ìƒ
      </div>
    </div>
  </div>
  
  <!-- 3Ã—3 ë¸”ëŸ¬ 2ë‹¨ê³„ -->
  <div class="row">
    <div class="block">
      <div class="comparison-container">
        <img id="originalImage4">
        <img class="original-overlay" id="originalOverlay4">
        <div id="positionMarkers4"></div>
      </div>
      <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="ninePixelCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay4a">
        <div id="gradientPoints4a"></div>
      </div>
      <p>â‘£ 9í”½ì…€ ë¸”ëŸ¬ - í”½ì…€ ì´ë¯¸ì§€ (3Ã—3)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="ninePixelBlurCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay4b">
        <div id="gradientPoints4b"></div>
      </div>
      <p>â‘£ 9í”½ì…€ ë¸”ëŸ¬ - ìµœì¢… ì´ë¯¸ì§€ (3Ã—3 + Blur)</p>
      <div id="explanation4" class="explanation" style="display: none;">
        <strong>â‘£ 9í”½ì…€ ë¸”ëŸ¬ í•´ì„¤:</strong><br>
        â€¢ ì™¼ìª½: 9ê°œ ì•ˆìª½ ì§€ì  ìƒ‰ìƒì„ 3Ã—3 ê·¸ë¦¬ë“œë¡œ ì§ì ‘ ë°°ì¹˜<br>
        â€¢ ì˜¤ë¥¸ìª½: 3Ã—3 í”½ì…€ ì´ë¯¸ì§€ì— Blur íš¨ê³¼ ì ìš©<br>
        â€¢ êµ¬ì„±: 3Ã—3 ê·¸ë¦¬ë“œ (TopLeft~BottomRight)
      </div>
    </div>
  </div>
  
  <!-- â‘¤ í‰ê·  ë°°ê²½ 2ë‹¨ê³„ -->
  <div class="row">
    <div class="block">
      <div class="comparison-container">
        <img id="originalImage5">
        <img class="original-overlay" id="originalOverlay5">
        <div id="positionMarkers5"></div>
      </div>
      <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="kmeansCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay5a">
      </div>
      <p>â‘¤ í‰ê·  ë°°ê²½ - K-means í´ëŸ¬ìŠ¤í„°ë§ ì ìš© (1ë“±~10ë“±)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="threePointCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay5b">
        <div id="gradientPoints5"></div>
      </div>
      <p>â‘¤ í‰ê·  ë°°ê²½ - ìµœì¢… ì´ë¯¸ì§€</p>
      <div id="explanation5" class="explanation" style="display: none;">
        <strong>â‘¤ ëŒ€í‘œìƒ‰+ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ í•´ì„¤:</strong><br>
        â€¢ 1ë‹¨ê³„: K-means í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ 5ê°œ ëŒ€í‘œ ìƒ‰ìƒ ì¶”ì¶œí•˜ì—¬ ì›ë³¸ ì´ë¯¸ì§€ì— ì ìš©<br>
        â€¢ 2ë‹¨ê³„: í‰ê·  ë°°ê²½ + 15ê°œ ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸ (5ìƒ‰ìƒ Ã— 3ìœ„ì¹˜)<br>
        â€¢ ìƒ‰ìƒ ì„ ì •: K-means í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ ì¶”ì¶œëœ 5ê°œ ëŒ€í‘œ ìƒ‰ìƒ<br>
        â€¢ êµ¬ì„±: ê° ëŒ€í‘œ ìƒ‰ìƒì´ í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ë°©ì‚¬í˜•ìœ¼ë¡œ í¼ì ¸ë‚˜ê°€ëŠ” íš¨ê³¼
      </div>
    </div>
  </div>
  
  <!-- â‘¥ ìµœë‹¤ ë¹ˆë„ ë°°ê²½ 2ë‹¨ê³„ -->
  <div class="row">
    <div class="block">
      <div class="comparison-container">
        <img id="originalImage6">
        <img class="original-overlay" id="originalOverlay6">
        <div id="positionMarkers6"></div>
      </div>
      <p>â‘  ì›ë³¸ (ì¶”ì¶œ ìœ„ì¹˜ í‘œì‹œ - â‘¤ ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="kmeansCanvas2"></canvas>
        <img class="original-overlay" id="originalOverlay6a">
      </div>
      <p>â‘¥ ìµœë‹¤ ë¹ˆë„ ë°°ê²½ - K-means í´ëŸ¬ìŠ¤í„°ë§ ì ìš© (1ë“±~10ë“±)</p>
    </div>
    <div class="block">
      <div class="comparison-container">
        <canvas id="dominantBackgroundCanvas"></canvas>
        <img class="original-overlay" id="originalOverlay6b">
        <div id="gradientPoints6"></div>
      </div>
      <p>â‘¥ ìµœë‹¤ ë¹ˆë„ ë°°ê²½ - ìµœì¢… ì´ë¯¸ì§€</p>
      <div id="explanation6" class="explanation" style="display: none;">
        <strong>â‘¥ ëŒ€í‘œìƒ‰+ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ í•´ì„¤:</strong><br>
        â€¢ 1ë‹¨ê³„: K-means í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ 5ê°œ ëŒ€í‘œ ìƒ‰ìƒ ì¶”ì¶œí•˜ì—¬ ì›ë³¸ ì´ë¯¸ì§€ì— ì ìš©<br>
        â€¢ 2ë‹¨ê³„: ìµœë‹¤ ë¹ˆë„ ë°°ê²½ + 15ê°œ ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸ (5ìƒ‰ìƒ Ã— 3ìœ„ì¹˜)<br>
        â€¢ ìƒ‰ìƒ ì„ ì •: K-means í´ëŸ¬ìŠ¤í„°ë§ìœ¼ë¡œ ì¶”ì¶œëœ 5ê°œ ëŒ€í‘œ ìƒ‰ìƒ<br>
        â€¢ êµ¬ì„±: ê° ëŒ€í‘œ ìƒ‰ìƒì´ í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ë°©ì‚¬í˜•ìœ¼ë¡œ í¼ì ¸ë‚˜ê°€ëŠ” íš¨ê³¼
      </div>
    </div>
  </div>

  <div id="dataOutput" class="data-output" style="display: none;">
    <h3>ğŸ“Š ì¶”ì¶œëœ ë°ì´í„°</h3>
    <pre id="dataContent"></pre>
  </div>

  <script type="module">
    import { encode, decode } from 'https://cdn.jsdelivr.net/npm/blurhash@2.0.5/+esm';

    const imageInput = document.getElementById('imageInput');
    const originalImage1 = document.getElementById('originalImage1');
    const originalImage2 = document.getElementById('originalImage2');
    const originalImage3 = document.getElementById('originalImage3');
    const originalImage4 = document.getElementById('originalImage4');
    const originalImage5 = document.getElementById('originalImage5');
    const originalImage6 = document.getElementById('originalImage6');
    const blurhashCanvas = document.getElementById('blurhashCanvas');
    const blurhash32Canvas = document.getElementById('blurhash32Canvas');
    const fourPixelCanvas = document.getElementById('fourPixelCanvas');
    const fourPixelBlurCanvas = document.getElementById('fourPixelBlurCanvas');
    const ninePixelCanvas = document.getElementById('ninePixelCanvas');
    const ninePixelBlurCanvas = document.getElementById('ninePixelBlurCanvas');
    const threePointCanvas = document.getElementById('threePointCanvas');
    const dominantBackgroundCanvas = document.getElementById('dominantBackgroundCanvas');
    const kmeansCanvas = document.getElementById('kmeansCanvas');
    const kmeansCanvas2 = document.getElementById('kmeansCanvas2');
    const dataOutput = document.getElementById('dataOutput');
    const dataContent = document.getElementById('dataContent');
    const positionMarkers1 = document.getElementById('positionMarkers1');
    const positionMarkers2 = document.getElementById('positionMarkers2');
    const positionMarkers3 = document.getElementById('positionMarkers3');
    const positionMarkers4 = document.getElementById('positionMarkers4');
    const positionMarkers5 = document.getElementById('positionMarkers5');
    const positionMarkers6 = document.getElementById('positionMarkers6');
    
    // ì²´í¬ë°•ìŠ¤ ìš”ì†Œë“¤
    const showOriginalMarkers = document.getElementById('showOriginalMarkers');
    const showGradientPoints = document.getElementById('showGradientPoints');
    const showExplanation = document.getElementById('showExplanation');

    // ì›ë³¸ ì˜¤ë²„ë ˆì´ ì´ë¯¸ì§€ë“¤
    const originalOverlays = [
      document.getElementById('originalOverlay1'),
      document.getElementById('originalOverlay2a'),
      document.getElementById('originalOverlay2b'),
      document.getElementById('originalOverlay3a'),
      document.getElementById('originalOverlay3b'),
      document.getElementById('originalOverlay4a'),
      document.getElementById('originalOverlay4b'),
      document.getElementById('originalOverlay5a'),
      document.getElementById('originalOverlay5b'),
      document.getElementById('originalOverlay6a'),
      document.getElementById('originalOverlay6b')
    ];

    // ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ ê³„ì‚° í•¨ìˆ˜
    function calculateDisplaySize(img, maxSize = 300) {
      const aspectRatio = img.width / img.height;
      let displayWidth, displayHeight;
      
      if (aspectRatio > 1) {
        // ê°€ë¡œê°€ ë” ê¸´ ê²½ìš°
        displayWidth = maxSize;
        displayHeight = maxSize / aspectRatio;
      } else {
        // ì„¸ë¡œê°€ ë” ê¸´ ê²½ìš°
        displayHeight = maxSize;
        displayWidth = maxSize * aspectRatio;
      }
      
      return { width: displayWidth, height: displayHeight };
    }

    imageInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      await img.decode();

      // ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ì— ë§ì¶° í‘œì‹œ í¬ê¸° ê³„ì‚°
      const displaySize = calculateDisplaySize(img);
      
      // ëª¨ë“  ì›ë³¸ ì´ë¯¸ì§€ ì„¤ì •
      const allOriginalImages = [originalImage1, originalImage2, originalImage3, originalImage4, originalImage5, originalImage6];
      allOriginalImages.forEach(imgElement => {
        if (imgElement) {
          imgElement.src = img.src;
          imgElement.style.width = displaySize.width + 'px';
          imgElement.style.height = displaySize.height + 'px';
        }
      });
      
      // ëª¨ë“  ìº”ë²„ìŠ¤ì˜ CSS ìŠ¤íƒ€ì¼ì„ ì›ë³¸ê³¼ ë™ì¼í•œ ë¹„ìœ¨ë¡œ ì„¤ì •
      const allCanvases = [
        blurhashCanvas, blurhash32Canvas,
        fourPixelCanvas, fourPixelBlurCanvas,
        ninePixelCanvas, ninePixelBlurCanvas,
        threePointCanvas, dominantBackgroundCanvas,
        kmeansCanvas, kmeansCanvas2
      ];
      
      allCanvases.forEach(canvas => {
        if (canvas) {
          canvas.style.width = displaySize.width + 'px';
          canvas.style.height = displaySize.height + 'px';
        }
      });

      // ëª¨ë“  ì˜¤ë²„ë ˆì´ì— ì›ë³¸ ì´ë¯¸ì§€ ì„¤ì • ë° ë¹„ìœ¨ ì¡°ì •
      originalOverlays.forEach(overlay => {
        if (overlay) {
          overlay.src = img.src;
          overlay.style.width = displaySize.width + 'px';
          overlay.style.height = displaySize.height + 'px';
        }
      });

      // BlurHash ìƒì„±
      const w = 32, h = 32;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = w;
      tempCanvas.height = h;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(img, 0, 0, w, h);
      const imageData = tempCtx.getImageData(0, 0, w, h);
      const hash = encode(imageData.data, w, h, 4, 4);

      // BlurHash 32í”½ì…€ ì´ë¯¸ì§€
      const blur32Ctx = blurhash32Canvas.getContext('2d');
      blurhash32Canvas.width = displaySize.width;
      blurhash32Canvas.height = displaySize.height;
      blur32Ctx.drawImage(img, 0, 0, displaySize.width, displaySize.height);
      
      // BlurHash ìµœì¢… ì´ë¯¸ì§€
      const blurCtx = blurhashCanvas.getContext('2d');
      blurhashCanvas.width = displaySize.width;
      blurhashCanvas.height = displaySize.height;
      const decoded = decode(hash, displaySize.width, displaySize.height);
      const blurImage = blurCtx.createImageData(displaySize.width, displaySize.height);
      blurImage.data.set(decoded);
      blurCtx.putImageData(blurImage, 0, 0);

      // 4í”½ì…€ ì½”ë„ˆ ìƒ‰ìƒ (2x2 í”½ì…€) - ì™¼ìª½ (blur ì—†ìŒ)
      const fourCtx = fourPixelCanvas.getContext('2d');
      fourPixelCanvas.width = displaySize.width;
      fourPixelCanvas.height = displaySize.height;
      const cornerColors = getFourCornerColors(img);
      
      // 2x2 í”½ì…€ì„ ì§ì ‘ ê·¸ë¦¬ê¸° (blur ì—†ìŒ) - ì›ë³¸ ë¹„ìœ¨ ê³ ë ¤
      const pixelWidth = displaySize.width / 2;
      const pixelHeight = displaySize.height / 2;
      fourCtx.imageSmoothingEnabled = false;
      
      // TopLeft
      fourCtx.fillStyle = cornerColors.topLeft;
      fourCtx.fillRect(0, 0, pixelWidth, pixelHeight);
      
      // TopRight
      fourCtx.fillStyle = cornerColors.topRight;
      fourCtx.fillRect(pixelWidth, 0, pixelWidth, pixelHeight);
      
      // BottomLeft
      fourCtx.fillStyle = cornerColors.bottomLeft;
      fourCtx.fillRect(0, pixelHeight, pixelWidth, pixelHeight);
      
      // BottomRight
      fourCtx.fillStyle = cornerColors.bottomRight;
      fourCtx.fillRect(pixelWidth, pixelHeight, pixelWidth, pixelHeight);
      
      // 4í”½ì…€ ë¸”ëŸ¬ ì´ë¯¸ì§€ (2x2 + blur) - ì˜¤ë¥¸ìª½
      const fourBlurCtx = fourPixelBlurCanvas.getContext('2d');
      fourPixelBlurCanvas.width = displaySize.width;
      fourPixelBlurCanvas.height = displaySize.height;
      
      // ë™ì¼í•œ 2x2 í”½ì…€ì„ ê·¸ë¦° í›„ blur ì ìš© - ì›ë³¸ ë¹„ìœ¨ ê³ ë ¤
      fourBlurCtx.imageSmoothingEnabled = false;
      
      // TopLeft
      fourBlurCtx.fillStyle = cornerColors.topLeft;
      fourBlurCtx.fillRect(0, 0, pixelWidth, pixelHeight);
      
      // TopRight
      fourBlurCtx.fillStyle = cornerColors.topRight;
      fourBlurCtx.fillRect(pixelWidth, 0, pixelWidth, pixelHeight);
      
      // BottomLeft
      fourBlurCtx.fillStyle = cornerColors.bottomLeft;
      fourBlurCtx.fillRect(0, pixelHeight, pixelWidth, pixelHeight);
      
      // BottomRight
      fourBlurCtx.fillStyle = cornerColors.bottomRight;
      fourBlurCtx.fillRect(pixelWidth, pixelHeight, pixelWidth, pixelHeight);
      
      // 2Ã—2ì— blur íš¨ê³¼ ì ìš©
      applyBlurEffect(fourBlurCtx, displaySize.width, displaySize.height, 8);

      // 9í”½ì…€ ë¸”ëŸ¬ (3Ã—3) - ì™¼ìª½ (blur ì—†ìŒ)
      const nineCtx = ninePixelCanvas.getContext('2d');
      ninePixelCanvas.width = displaySize.width;
      ninePixelCanvas.height = displaySize.height;
      const nineColors = getNineCornerColors(img);
      
      // ë””ë²„ê¹…ì„ ìœ„í•œ ì½˜ì†” ì¶œë ¥
      console.log('9í”½ì…€ ìƒ‰ìƒ:', nineColors);
      console.log('ìº”ë²„ìŠ¤ í¬ê¸°:', displaySize.width, 'x', displaySize.height);
      console.log('í”½ì…€ í¬ê¸°:', displaySize.width / 3, 'x', displaySize.height / 3);
      
      // 3Ã—3 í”½ì…€ì„ ì§ì ‘ ê·¸ë¦¬ê¸° (blur ì—†ìŒ) - ì›ë³¸ ë¹„ìœ¨ ê³ ë ¤
      const ninePixelWidth = displaySize.width / 3;
      const ninePixelHeight = displaySize.height / 3;
      nineCtx.imageSmoothingEnabled = false;
      
      // Top Row
      nineCtx.fillStyle = nineColors.topLeft;
      nineCtx.fillRect(0, 0, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.topCenter;
      nineCtx.fillRect(ninePixelWidth, 0, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.topRight;
      nineCtx.fillRect(ninePixelWidth * 2, 0, ninePixelWidth, ninePixelHeight);
      
      // Middle Row
      nineCtx.fillStyle = nineColors.middleLeft;
      nineCtx.fillRect(0, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.middleCenter;
      nineCtx.fillRect(ninePixelWidth, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.middleRight;
      nineCtx.fillRect(ninePixelWidth * 2, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      // Bottom Row
      nineCtx.fillStyle = nineColors.bottomLeft;
      nineCtx.fillRect(0, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.bottomCenter;
      nineCtx.fillRect(ninePixelWidth, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      nineCtx.fillStyle = nineColors.bottomRight;
      nineCtx.fillRect(ninePixelWidth * 2, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      // 9í”½ì…€ ë¸”ëŸ¬ ì´ë¯¸ì§€ (3Ã—3 + blur) - ì˜¤ë¥¸ìª½
      const nineBlurCtx = ninePixelBlurCanvas.getContext('2d');
      ninePixelBlurCanvas.width = displaySize.width;
      ninePixelBlurCanvas.height = displaySize.height;
      
      // ë™ì¼í•œ 3Ã—3 í”½ì…€ì„ ê·¸ë¦° í›„ blur ì ìš© - ì›ë³¸ ë¹„ìœ¨ ê³ ë ¤
      nineBlurCtx.imageSmoothingEnabled = false;
      
      // Top Row
      nineBlurCtx.fillStyle = nineColors.topLeft;
      nineBlurCtx.fillRect(0, 0, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.topCenter;
      nineBlurCtx.fillRect(ninePixelWidth, 0, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.topRight;
      nineBlurCtx.fillRect(ninePixelWidth * 2, 0, ninePixelWidth, ninePixelHeight);
      
      // Middle Row
      nineBlurCtx.fillStyle = nineColors.middleLeft;
      nineBlurCtx.fillRect(0, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.middleCenter;
      nineBlurCtx.fillRect(ninePixelWidth, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.middleRight;
      nineBlurCtx.fillRect(ninePixelWidth * 2, ninePixelHeight, ninePixelWidth, ninePixelHeight);
      
      // Bottom Row
      nineBlurCtx.fillStyle = nineColors.bottomLeft;
      nineBlurCtx.fillRect(0, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.bottomCenter;
      nineBlurCtx.fillRect(ninePixelWidth, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      nineBlurCtx.fillStyle = nineColors.bottomRight;
      nineBlurCtx.fillRect(ninePixelWidth * 2, ninePixelHeight * 2, ninePixelWidth, ninePixelHeight);
      
      // 3Ã—3ì— blur íš¨ê³¼ ì ìš©
      applyBlurEffect(nineBlurCtx, displaySize.width, displaySize.height, 6);

      // ëŒ€í‘œ ìƒ‰ìƒ + ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ (í‰ê·  ë°°ê²½)
      const threeCtx = threePointCanvas.getContext('2d');
      threePointCanvas.width = displaySize.width;
      threePointCanvas.height = displaySize.height;
      const domColors = getDominantColors(img, 5);
      const allPositions = domColors.map(c => getColorPositions(img, c, 3)); // ê° ìƒ‰ìƒë‹¹ 3ê°œ ìœ„ì¹˜
      
      // ì¶”ì¶œëœ ìœ„ì¹˜ ì •ë³´ë¥¼ ì „ì—­ ë³€ìˆ˜ì— ì €ì¥ (í‘œì‹œìš©)
      window.lastAllPositions = allPositions;
      window.lastOriginalWidth = img.width;
      window.lastOriginalHeight = img.height;
      
      // ë””ë²„ê¹…ì„ ìœ„í•œ ì½˜ì†” ì¶œë ¥
      console.log('ëŒ€í‘œ ìƒ‰ìƒ:', domColors);
      console.log('ìœ„ì¹˜ë“¤:', allPositions);
      
      // ìœ„ì¹˜ ë§ˆì»¤ í‘œì‹œ (ëª¨ë“  rowì— ëŒ€í•´)
      const allPositionMarkers = [positionMarkers1, positionMarkers2, positionMarkers3, positionMarkers4, positionMarkers5, positionMarkers6];
      allPositionMarkers.forEach(markers => {
        if (markers) {
          displayPositionMarkers(img, cornerColors, domColors, allPositions, markers);
        }
      });
      
      // ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€ì  í‘œì‹œ
      displayGradientPoints();
      
      // í•´ì„¤ í‘œì‹œ
      displayExplanations();
      
      // í‰ê·  ìƒ‰ìƒê³¼ ìµœë‹¤ ë¹ˆë„ ìƒ‰ìƒ ê³„ì‚°
      const avg = getAverageColor(img);
      const dominantBgColor = getMostFrequentColor(img);
      
      // ë°ì´í„° êµ¬ì¡° ìƒì„±
      const extractedData = createDataStructure(avg, domColors, allPositions, hash, cornerColors);
      displayData(extractedData);
      
      // â‘¤ í‰ê·  ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸
      drawThreeColorPositionBlend(threeCtx, displaySize.width, displaySize.height, avg, domColors, allPositions);
      
      // K-means í´ëŸ¬ìŠ¤í„°ë§ ê²°ê³¼ë¥¼ ì´ë¯¸ì§€ì— ì ìš©í•˜ëŠ” í•¨ìˆ˜ (ë‹¨ìˆœ ë²„ì „)
      function drawKmeansAppliedImage(ctx, width, height, img, colors) {
        // ì„ì‹œ ìº”ë²„ìŠ¤ì— ì›ë³¸ ì´ë¯¸ì§€ ê·¸ë¦¬ê¸°
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = img.width;
        tempCanvas.height = img.height;
        tempCtx.drawImage(img, 0, 0);
        
        const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
        const data = imageData.data;
        
        // ê° í”½ì…€ì„ ê°€ì¥ ê°€ê¹Œìš´ í´ëŸ¬ìŠ¤í„° ìƒ‰ìƒìœ¼ë¡œ ë³€ê²½
        for (let i = 0; i < data.length; i += 4) {
          const pixelColor = [data[i], data[i + 1], data[i + 2]];
          
          // ê°€ì¥ ê°€ê¹Œìš´ í´ëŸ¬ìŠ¤í„° ì°¾ê¸°
          let minDistance = Infinity;
          let closestColor = colors[0];
          
          colors.forEach(color => {
            const distance = euclideanDistance(pixelColor, [color.r, color.g, color.b]);
            if (distance < minDistance) {
              minDistance = distance;
              closestColor = color;
            }
          });
          
          // í´ëŸ¬ìŠ¤í„° ìƒ‰ìƒìœ¼ë¡œ ë³€ê²½
          data[i] = closestColor.r;
          data[i + 1] = closestColor.g;
          data[i + 2] = closestColor.b;
        }
        
        // ê²°ê³¼ë¥¼ ëŒ€ìƒ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        tempCtx.putImageData(imageData, 0, 0);
        ctx.drawImage(tempCanvas, 0, 0, width, height);
        console.log('drawKmeansAppliedImage ì™„ë£Œ');
      }
      
      // Blur íš¨ê³¼ë¥¼ ì ìš©í•˜ëŠ” í•¨ìˆ˜
      function applyBlurEffect(ctx, width, height, blurRadius = 6) {
        // í˜„ì¬ ìº”ë²„ìŠ¤ ë‚´ìš©ì„ ê°€ì ¸ì˜¤ê¸°
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;
        
        // ê°€ìš°ì‹œì•ˆ ë¸”ëŸ¬ í•„í„° ì ìš©
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = width;
        tempCanvas.height = height;
        tempCtx.putImageData(imageData, 0, 0);
        
        // CSS í•„í„°ë¥¼ ì‚¬ìš©í•œ ë¸”ëŸ¬ íš¨ê³¼
        tempCtx.filter = `blur(${blurRadius}px)`;
        tempCtx.drawImage(tempCanvas, 0, 0);
        
        // ë¸”ëŸ¬ëœ ê²°ê³¼ë¥¼ ì›ë˜ ìº”ë²„ìŠ¤ì— ê·¸ë¦¬ê¸°
        const blurredData = tempCtx.getImageData(0, 0, width, height);
        ctx.putImageData(blurredData, 0, 0);
      }
      
      // â‘¤ K-means í´ëŸ¬ìŠ¤í„°ë§ ì´ë¯¸ì§€ (1ë“±ë¶€í„° 10ë“±ê¹Œì§€)
      console.log('kmeansCanvas ìš”ì†Œ:', kmeansCanvas);
      console.log('domColors:', domColors);
      const kmeansCtx = kmeansCanvas.getContext('2d');
      kmeansCanvas.width = displaySize.width;
      kmeansCanvas.height = displaySize.height;
      kmeansCanvas.style.width = displaySize.width + 'px';
      kmeansCanvas.style.height = displaySize.height + 'px';
      console.log('â‘¤ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì‹œì‘:', displaySize.width, 'x', displaySize.height);
      
      if (domColors && domColors.length > 0) {
        drawKmeansAppliedImage(kmeansCtx, displaySize.width, displaySize.height, img, domColors);
        console.log('â‘¤ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì™„ë£Œ');
      } else {
        console.error('domColorsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤!');
        // ê¸°ë³¸ ìƒ‰ìƒìœ¼ë¡œ í…ŒìŠ¤íŠ¸
        const testColors = [
          { r: 255, g: 0, b: 0 },
          { r: 0, g: 255, b: 0 },
          { r: 0, g: 0, b: 255 }
        ];
        drawKmeansAppliedImage(kmeansCtx, displaySize.width, displaySize.height, img, testColors);
        console.log('â‘¤ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì™„ë£Œ (í…ŒìŠ¤íŠ¸ ìƒ‰ìƒ ì‚¬ìš©)');
      }
      
      // â‘¥ K-means í´ëŸ¬ìŠ¤í„°ë§ ì´ë¯¸ì§€ (ë™ì¼)
      console.log('kmeansCanvas2 ìš”ì†Œ:', kmeansCanvas2);
      const kmeansCtx2 = kmeansCanvas2.getContext('2d');
      kmeansCanvas2.width = displaySize.width;
      kmeansCanvas2.height = displaySize.height;
      kmeansCanvas2.style.width = displaySize.width + 'px';
      kmeansCanvas2.style.height = displaySize.height + 'px';
      console.log('â‘¥ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì‹œì‘:', displaySize.width, 'x', displaySize.height);
      
      if (domColors && domColors.length > 0) {
        drawKmeansAppliedImage(kmeansCtx2, displaySize.width, displaySize.height, img, domColors);
        console.log('â‘¥ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì™„ë£Œ');
      } else {
        console.error('domColorsê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤! (â‘¥ë²ˆ)');
        // ê¸°ë³¸ ìƒ‰ìƒìœ¼ë¡œ í…ŒìŠ¤íŠ¸
        const testColors = [
          { r: 255, g: 0, b: 0 },
          { r: 0, g: 255, b: 0 },
          { r: 0, g: 0, b: 255 }
        ];
        drawKmeansAppliedImage(kmeansCtx2, displaySize.width, displaySize.height, img, testColors);
        console.log('â‘¥ K-means ì´ë¯¸ì§€ ê·¸ë¦¬ê¸° ì™„ë£Œ (í…ŒìŠ¤íŠ¸ ìƒ‰ìƒ ì‚¬ìš©)');
      }
      
      // â‘¥ ìµœë‹¤ ë¹ˆë„ ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸
      const dominantCtx = dominantBackgroundCanvas.getContext('2d');
      dominantBackgroundCanvas.width = displaySize.width;
      dominantBackgroundCanvas.height = displaySize.height;
      
      // â‘¥ë²ˆì§¸ ì´ë¯¸ì§€ìš© ìœ„ì¹˜ ì •ë³´ë„ ì €ì¥
      window.lastAllPositions2 = allPositions;
      
      drawThreeColorPositionBlend(dominantCtx, displaySize.width, displaySize.height, dominantBgColor, domColors, allPositions);
      
      // 5ìƒ‰ìƒ Ã— 3ìœ„ì¹˜ ì •ë³´ë¥¼ ê²°ê³¼ íŒ¨ë„ì— í‘œì‹œ
      displayColorPositionInfo(domColors, allPositions);
      
      // ì›ë³¸ ì´ë¯¸ì§€ì—ë„ ìƒ‰ìƒ ì •ë³´ í‘œì‹œ
      displayColorInfoOnOriginal(domColors, allPositions);
    });

    // 5ìƒ‰ìƒ Ã— 3ìœ„ì¹˜ ì •ë³´ë¥¼ ê²°ê³¼ íŒ¨ë„ì— í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
    function displayColorPositionInfo(domColors, allPositions) {
      console.log('ìƒ‰ìƒ ìœ„ì¹˜ ì •ë³´ í‘œì‹œ ì‹œì‘:', domColors, allPositions);
      
      // ê²°ê³¼ íŒ¨ë„ë“¤ ì°¾ê¸°
      const resultPanels = [
        document.querySelector('#kmeansCanvas').parentElement,
        document.querySelector('#kmeansCanvas2').parentElement,
        document.querySelector('#dominantBackgroundCanvas').parentElement
      ];
      
      resultPanels.forEach((panel, panelIndex) => {
        if (!panel) return;
        
        // ê¸°ì¡´ ì •ë³´ ì œê±°
        const existingInfo = panel.querySelector('.color-position-info');
        if (existingInfo) {
          existingInfo.remove();
        }
        
        // ì •ë³´ ì»¨í…Œì´ë„ˆ ìƒì„±
        const infoContainer = document.createElement('div');
        infoContainer.className = 'color-position-info';
        infoContainer.style.cssText = `
          position: absolute;
          top: 10px;
          left: 10px;
          background: rgba(0,0,0,0.8);
          color: white;
          padding: 10px;
          border-radius: 5px;
          font-size: 12px;
          font-family: monospace;
          z-index: 100;
          max-width: 200px;
          max-height: 150px;
          overflow-y: auto;
          opacity: 0.7;
          transition: opacity 0.3s ease;
          cursor: pointer;
        `;
        
        // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ íˆ¬ëª…ë„ ë³€ê²½
        infoContainer.addEventListener('mouseenter', () => {
          infoContainer.style.opacity = '1';
        });
        
        infoContainer.addEventListener('mouseleave', () => {
          infoContainer.style.opacity = '0.7';
        });
        
        let infoHTML = '<strong>5ìƒ‰ìƒ Ã— 3ìœ„ì¹˜</strong><br><br>';
        
        if (domColors && domColors.length > 0) {
          domColors.forEach((color, colorIndex) => {
            const positions = allPositions[colorIndex];
            infoHTML += `<div style="margin-bottom: 8px;">
              <span style="display: inline-block; width: 15px; height: 15px; background: rgb(${color.r},${color.g},${color.b}); border: 1px solid white; margin-right: 5px;"></span>
              <strong>ìƒ‰ìƒ ${colorIndex + 1}:</strong> RGB(${color.r}, ${color.g}, ${color.b})<br>
              <span style="margin-left: 20px; font-size: 11px;">`;
            
            if (positions && positions.length > 0) {
              positions.forEach((pos, posIndex) => {
                infoHTML += `ìœ„ì¹˜ ${posIndex + 1}: (${pos.x}, ${pos.y})<br>`;
              });
            } else {
              infoHTML += 'ìœ„ì¹˜ ì •ë³´ ì—†ìŒ<br>';
            }
            
            infoHTML += '</span></div>';
          });
        } else {
          infoHTML += '<span style="color: #ff6b6b;">ìƒ‰ìƒ ì •ë³´ ì—†ìŒ</span>';
        }
        
        infoContainer.innerHTML = infoHTML;
        panel.appendChild(infoContainer);
        
        // íŒ¨ë„ì— relative í¬ì§€ì…˜ ì¶”ê°€
        panel.style.position = 'relative';
      });
      
      console.log('ìƒ‰ìƒ ìœ„ì¹˜ ì •ë³´ í‘œì‹œ ì™„ë£Œ');
    }
    
    // ì›ë³¸ ì´ë¯¸ì§€ì— ìƒ‰ìƒ ì •ë³´ë¥¼ í‘œì‹œí•˜ëŠ” í•¨ìˆ˜
    function displayColorInfoOnOriginal(domColors, allPositions) {
      console.log('ì›ë³¸ ì´ë¯¸ì§€ì— ìƒ‰ìƒ ì •ë³´ í‘œì‹œ ì‹œì‘');
      
      // ì›ë³¸ ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆë“¤ ì°¾ê¸°
      const originalContainers = [
        document.querySelector('#originalImage1').parentElement,
        document.querySelector('#originalImage2').parentElement,
        document.querySelector('#originalImage3').parentElement,
        document.querySelector('#originalImage4').parentElement,
        document.querySelector('#originalImage5').parentElement
      ];
      
      originalContainers.forEach((container, containerIndex) => {
        if (!container) return;
        
        // ê¸°ì¡´ ì •ë³´ ì œê±°
        const existingInfo = container.querySelector('.original-color-info');
        if (existingInfo) {
          existingInfo.remove();
        }
        
        // ì •ë³´ ì»¨í…Œì´ë„ˆ ìƒì„±
        const infoContainer = document.createElement('div');
        infoContainer.className = 'original-color-info';
        infoContainer.style.cssText = `
          position: absolute;
          bottom: 10px;
          right: 10px;
          background: rgba(0,0,0,0.9);
          color: white;
          padding: 8px;
          border-radius: 4px;
          font-size: 11px;
          font-family: monospace;
          z-index: 50;
          max-width: 180px;
          max-height: 120px;
          overflow-y: auto;
          opacity: 0.8;
          transition: opacity 0.3s ease;
        `;
        
        let infoHTML = '<strong>ì¶”ì¶œëœ ìƒ‰ìƒ</strong><br>';
        
        if (domColors && domColors.length > 0) {
          domColors.forEach((color, colorIndex) => {
            const positions = allPositions[colorIndex];
            const positionCount = positions ? positions.length : 0;
            
            infoHTML += `<div style="margin: 2px 0;">
              <span style="display: inline-block; width: 12px; height: 12px; background: rgb(${color.r},${color.g},${color.b}); border: 1px solid white; margin-right: 3px;"></span>
              <span style="font-size: 10px;">ìƒ‰ìƒ${colorIndex + 1}: ${positionCount}ê°œ ìœ„ì¹˜</span>
            </div>`;
          });
        } else {
          infoHTML += '<span style="color: #ff6b6b; font-size: 10px;">ìƒ‰ìƒ ì •ë³´ ì—†ìŒ</span>';
        }
        
        infoContainer.innerHTML = infoHTML;
        container.appendChild(infoContainer);
        
        // ì»¨í…Œì´ë„ˆì— relative í¬ì§€ì…˜ ì¶”ê°€
        container.style.position = 'relative';
        
        // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ íˆ¬ëª…ë„ ë³€ê²½
        infoContainer.addEventListener('mouseenter', () => {
          infoContainer.style.opacity = '1';
        });
        
        infoContainer.addEventListener('mouseleave', () => {
          infoContainer.style.opacity = '0.8';
        });
      });
      
      console.log('ì›ë³¸ ì´ë¯¸ì§€ì— ìƒ‰ìƒ ì •ë³´ í‘œì‹œ ì™„ë£Œ');
    }

    // ìœ„ì¹˜ ë§ˆì»¤ í‘œì‹œ í•¨ìˆ˜ (ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ ê³ ë ¤)
    function displayPositionMarkers(img, cornerColors, domColors, allPositions, markersContainer = positionMarkers1) {
      // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
      markersContainer.innerHTML = '';
      
      // ì›ë³¸ ì´ë¯¸ì§€ì˜ í˜„ì¬ í‘œì‹œ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
      const originalImage = document.getElementById('originalImage1');
      const displayWidth = parseInt(originalImage.style.width) || 300;
      const displayHeight = parseInt(originalImage.style.height) || 300;
      const scaleX = displayWidth / img.width;
      const scaleY = displayHeight / img.height;
      
      // 4ê°œ ì•ˆìª½ ì§€ì  ë§ˆì»¤ ì¶”ê°€
      const marginX = Math.floor(img.width * 0.10);
      const marginY = Math.floor(img.height * 0.10);
      
      const cornerPositions = [
        { x: marginX, y: marginY, label: 'TopLeft' },
        { x: img.width - 1 - marginX, y: marginY, label: 'TopRight' },
        { x: marginX, y: img.height - 1 - marginY, label: 'BottomLeft' },
        { x: img.width - 1 - marginX, y: img.height - 1 - marginY, label: 'BottomRight' }
      ];
      
      // 9ê°œ ì•ˆìª½ ì§€ì  ë§ˆì»¤ ì¶”ê°€ (3Ã—3)
      const sectionWidth = img.width / 3;
      const sectionHeight = img.height / 3;
      
      const ninePositions = [
        { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight / 2), label: 'TL' },
        { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight / 2), label: 'TC' },
        { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight / 2), label: 'TR' },
        { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2), label: 'ML' },
        { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2), label: 'MC' },
        { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2), label: 'MR' },
        { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2), label: 'BL' },
        { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2), label: 'BC' },
        { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2), label: 'BR' }
      ];
      
      cornerPositions.forEach((pos, index) => {
        const marker = document.createElement('div');
        marker.className = 'position-marker corner';
        marker.style.left = (pos.x * scaleX - 4) + 'px';
        marker.style.top = (pos.y * scaleY - 4) + 'px';
        
        const label = document.createElement('div');
        label.className = 'position-label';
        label.textContent = pos.label;
        label.style.left = (pos.x * scaleX) + 'px';
        label.style.top = (pos.y * scaleY) + 'px';
        
        markersContainer.appendChild(marker);
        markersContainer.appendChild(label);
      });
      
      // 9í”½ì…€ ë§ˆì»¤ ì¶”ê°€ (3Ã—3)
      ninePositions.forEach((pos, index) => {
        const marker = document.createElement('div');
        marker.className = 'position-marker corner';
        marker.style.left = (pos.x * scaleX - 4) + 'px';
        marker.style.top = (pos.y * scaleY - 4) + 'px';
        
        const label = document.createElement('div');
        label.className = 'position-label';
        label.textContent = pos.label;
        label.style.left = (pos.x * scaleX) + 'px';
        label.style.top = (pos.y * scaleY) + 'px';
        
        markersContainer.appendChild(marker);
        markersContainer.appendChild(label);
      });
      
      // ëŒ€í‘œ ìƒ‰ìƒ ë§ˆì»¤ ì¶”ê°€ (ì—¬ëŸ¬ ìœ„ì¹˜)
      domColors.forEach((color, colorIndex) => {
        const positions = allPositions[colorIndex];
        
        if (positions && positions.length > 0) {
          positions.forEach((pos, posIndex) => {
            const marker = document.createElement('div');
            marker.className = `position-marker dominant color${colorIndex + 1}`;
            marker.style.left = (pos.x * scaleX - 4) + 'px';
            marker.style.top = (pos.y * scaleY - 4) + 'px';
            
            // ìƒ‰ìƒ ì •ë³´ë¥¼ íˆ´íŒìœ¼ë¡œ í‘œì‹œ
            marker.title = `ìƒ‰ìƒ ${colorIndex + 1}: RGB(${color.r}, ${color.g}, ${color.b}) - ìœ„ì¹˜ ${posIndex + 1}`;
            
            // ì²« ë²ˆì§¸ ìœ„ì¹˜ë§Œ ë ˆì´ë¸” í‘œì‹œ
            if (posIndex === 0) {
              const label = document.createElement('div');
              label.className = 'position-label';
              label.textContent = `Dom${colorIndex + 1}`;
              label.style.left = (pos.x * scaleX) + 'px';
              label.style.top = (pos.y * scaleY) + 'px';
              markersContainer.appendChild(label);
            }
            
            markersContainer.appendChild(marker);
          });
        }
      });
      
      // â‘¤ ëŒ€í‘œìƒ‰+ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ ì „ìš© ë§ˆì»¤ ì¶”ê°€
      if (domColors.length > 0) {
        const gradientInfo = document.createElement('div');
        gradientInfo.style.position = 'absolute';
        gradientInfo.style.top = '10px';
        gradientInfo.style.left = '10px';
        gradientInfo.style.background = 'rgba(0,0,0,0.8)';
        gradientInfo.style.color = 'white';
        gradientInfo.style.padding = '8px';
        gradientInfo.style.borderRadius = '4px';
        gradientInfo.style.fontSize = '12px';
        gradientInfo.style.zIndex = '40';
        markersContainer.appendChild(gradientInfo);
      }
    }

    // í‰ê·  ìƒ‰ìƒ ì¶”ì¶œ
    function getAverageColor(img) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      let r = 0, g = 0, b = 0;
      for (let i = 0; i < data.length; i += 4) {
        r += data[i];
        g += data[i + 1];
        b += data[i + 2];
      }
      
      const pixelCount = data.length / 4;
      return {
        r: Math.round(r / pixelCount),
        g: Math.round(g / pixelCount),
        b: Math.round(b / pixelCount)
      };
    }

    // ìµœë‹¤ ë¹ˆë„ ìƒ‰ìƒ ì¶”ì¶œ
    function getMostFrequentColor(img) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      // ìƒ‰ìƒ ë¹ˆë„ ì¹´ìš´íŠ¸ (ì„±ëŠ¥ì„ ìœ„í•´ ìƒ˜í”Œë§)
      const colorCount = {};
      const step = Math.max(1, Math.floor(data.length / 4 / 1000));
      
      for (let i = 0; i < data.length; i += step * 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // ìƒ‰ìƒì„ ê·¸ë£¹í™”í•˜ì—¬ ì¹´ìš´íŠ¸ (ì •í™•ë„ë¥¼ ìœ„í•´ ë°˜ì˜¬ë¦¼)
        const colorKey = `${Math.round(r/10)*10},${Math.round(g/10)*10},${Math.round(b/10)*10}`;
        colorCount[colorKey] = (colorCount[colorKey] || 0) + 1;
      }
      
      // ê°€ì¥ ë¹ˆë„ê°€ ë†’ì€ ìƒ‰ìƒ ì°¾ê¸°
      let maxCount = 0;
      let mostFrequentColor = { r: 0, g: 0, b: 0 };
      
      for (const colorKey in colorCount) {
        if (colorCount[colorKey] > maxCount) {
          maxCount = colorCount[colorKey];
          const [r, g, b] = colorKey.split(',').map(Number);
          mostFrequentColor = { r, g, b };
        }
      }
      
      return mostFrequentColor;
    }

    // 4ê°œ ì•ˆìª½ ì§€ì  ìƒ‰ìƒ ì¶”ì¶œ
    function getFourCornerColors(img) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      function getPixelColor(x, y) {
        const index = (y * width + x) * 4;
        const r = data[index];
        const g = data[index + 1];
        const b = data[index + 2];
        return `rgb(${r}, ${g}, ${b})`;
      }
      
      // ì•ˆìª½ ì§€ì ì—ì„œ ìƒ‰ìƒ ì¶”ì¶œ (ëª¨ì„œë¦¬ì—ì„œ 10% ì•ˆìª½)
      const marginX = Math.floor(width * 0.10);
      const marginY = Math.floor(height * 0.10);
      
      return {
        topLeft: getPixelColor(marginX, marginY),
        topRight: getPixelColor(width - 1 - marginX, marginY),
        bottomLeft: getPixelColor(marginX, height - 1 - marginY),
        bottomRight: getPixelColor(width - 1 - marginX, height - 1 - marginY)
      };
    }

          // 9ê°œ ì•ˆìª½ ì§€ì  ìƒ‰ìƒ ì¶”ì¶œ (3Ã—3)
      function getNineCornerColors(img) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = canvas.width;
        const height = canvas.height;
        
        function getPixelColor(x, y) {
          const index = (y * width + x) * 4;
          const r = data[index];
          const g = data[index + 1];
          const b = data[index + 2];
          return `rgb(${r}, ${g}, ${b})`;
        }
        
        // 3Ã—3 ê·¸ë¦¬ë“œì˜ ê° ì„¹ì…˜ ì¤‘ì•™ì—ì„œ ìƒ‰ìƒ ì¶”ì¶œ
        const sectionWidth = width / 3;
        const sectionHeight = height / 3;
        
        // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸
        console.log('ì´ë¯¸ì§€ í¬ê¸°:', width, 'x', height);
        console.log('ì„¹ì…˜ í¬ê¸°:', sectionWidth, 'x', sectionHeight);
        
        const positions = {
          topLeft: { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight / 2) },
          topCenter: { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight / 2) },
          topRight: { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight / 2) },
          middleLeft: { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2) },
          middleCenter: { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2) },
          middleRight: { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight + sectionHeight / 2) },
          bottomLeft: { x: Math.round(sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2) },
          bottomCenter: { x: Math.round(sectionWidth + sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2) },
          bottomRight: { x: Math.round(sectionWidth * 2 + sectionWidth / 2), y: Math.round(sectionHeight * 2 + sectionHeight / 2) }
        };
        
        console.log('ì¶”ì¶œ ìœ„ì¹˜:', positions);
        
        return {
          topLeft: getPixelColor(positions.topLeft.x, positions.topLeft.y),
          topCenter: getPixelColor(positions.topCenter.x, positions.topCenter.y),
          topRight: getPixelColor(positions.topRight.x, positions.topRight.y),
          middleLeft: getPixelColor(positions.middleLeft.x, positions.middleLeft.y),
          middleCenter: getPixelColor(positions.middleCenter.x, positions.middleCenter.y),
          middleRight: getPixelColor(positions.middleRight.x, positions.middleRight.y),
          bottomLeft: getPixelColor(positions.bottomLeft.x, positions.bottomLeft.y),
          bottomCenter: getPixelColor(positions.bottomCenter.x, positions.bottomCenter.y),
          bottomRight: getPixelColor(positions.bottomRight.x, positions.bottomRight.y)
        };
      }

    // ëŒ€í‘œ ìƒ‰ìƒ ì¶”ì¶œ (K-means í´ëŸ¬ìŠ¤í„°ë§ + ë‹¤ì–‘ì„± ë³´ì¥)
    function getDominantColors(img, count) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      const pixels = [];
      
      // ìƒ˜í”Œë§ (ì„±ëŠ¥ í–¥ìƒ)
      const step = Math.max(1, Math.floor(data.length / 4 / 1000));
      for (let i = 0; i < data.length; i += step * 4) {
        pixels.push([data[i], data[i + 1], data[i + 2]]);
      }
      
      // ìƒ‰ìƒ ë‹¤ì–‘ì„± ê²€ì¦ í•¨ìˆ˜
      function isColorDiverse(newColor, existingColors, minDistance = 80) {
        for (const existing of existingColors) {
          const distance = euclideanDistance(
            [newColor.r, newColor.g, newColor.b],
            [existing.r, existing.g, existing.b]
          );
          if (distance < minDistance) {
            return false;
          }
        }
        return true;
      }
      
      // K-means í´ëŸ¬ìŠ¤í„°ë§ (ì •í™•íˆ countë§Œí¼ ìƒì„±)
      const extraClusters = kMeansClustering(pixels, count);
      
              // ìƒ‰ìƒ ê°•í™” í•¨ìˆ˜ (ë” ìƒìƒí•˜ê²Œ)
        function enhanceColor(color, factor = 1.2) {
        // NaN ê²€ì¦
        if (!color || isNaN(color.r) || isNaN(color.g) || isNaN(color.b)) {
          return { r: 128, g: 128, b: 128 };
        }
        
        return {
          r: Math.max(0, Math.min(255, Math.round(color.r * factor))),
          g: Math.max(0, Math.min(255, Math.round(color.g * factor))),
          b: Math.max(0, Math.min(255, Math.round(color.b * factor)))
        };
      }
      
      // ëŒ€ë¹„ ê°•í™” í•¨ìˆ˜ (ë” ê°•í•˜ê²Œ)
      function enhanceContrast(color, factor = 1.2) {
        // NaN ê²€ì¦
        if (!color || isNaN(color.r) || isNaN(color.g) || isNaN(color.b)) {
          return { r: 128, g: 128, b: 128 };
        }
        
        const avg = (color.r + color.g + color.b) / 3;
        return {
          r: Math.max(0, Math.min(255, Math.round((color.r - avg) * factor + avg))),
          g: Math.max(0, Math.min(255, Math.round((color.g - avg) * factor + avg))),
          b: Math.max(0, Math.min(255, Math.round((color.b - avg) * factor + avg)))
        };
      }
      
      // ì±„ë„ ê°•í™” í•¨ìˆ˜
      function enhanceSaturation(color, factor = 1.2) {
        // NaN ê²€ì¦
        if (!color || isNaN(color.r) || isNaN(color.g) || isNaN(color.b)) {
          return { r: 128, g: 128, b: 128 };
        }
        
        const max = Math.max(color.r, color.g, color.b);
        const min = Math.min(color.r, color.g, color.b);
        const delta = max - min;
        
        if (delta === 0) return color;
        
        const saturation = delta / max;
        const enhancedSaturation = Math.min(1, saturation * factor);
        
        const newDelta = max * enhancedSaturation;
        const mid = max - newDelta;
        
        return {
          r: Math.max(0, Math.min(255, Math.round(color.r === max ? max : (color.r === min ? mid : color.r)))),
          g: Math.max(0, Math.min(255, Math.round(color.g === max ? max : (color.g === min ? mid : color.g)))),
          b: Math.max(0, Math.min(255, Math.round(color.b === max ? max : (color.b === min ? mid : color.b))))
        };
      }
      
      // í´ëŸ¬ìŠ¤í„°ë¥¼ ìƒ‰ìƒìœ¼ë¡œ ë³€í™˜í•˜ê³  ì‚¬ìš© ë¹ˆë„ ê¸°ë°˜ìœ¼ë¡œ ì •ë ¬
      const allColors = [];
      
      for (const cluster of extraClusters) {
        const avg = cluster.reduce((acc, pixel) => {
          acc[0] += pixel[0];
          acc[1] += pixel[1];
          acc[2] += pixel[2];
          return acc;
        }, [0, 0, 0]);
        
        const baseColor = {
          r: Math.max(0, Math.min(255, Math.round(avg[0] / cluster.length))),
          g: Math.max(0, Math.min(255, Math.round(avg[1] / cluster.length))),
          b: Math.max(0, Math.min(255, Math.round(avg[2] / cluster.length)))
        };
        
        // NaN ê²€ì¦
        if (isNaN(baseColor.r) || isNaN(baseColor.g) || isNaN(baseColor.b)) {
          console.warn('í´ëŸ¬ìŠ¤í„°ì—ì„œ NaN ìƒ‰ìƒ ìƒì„±:', cluster.length, avg);
          baseColor.r = 128;
          baseColor.g = 128;
          baseColor.b = 128;
        }
        
        // ìƒ‰ìƒ ê°•í™”, ëŒ€ë¹„ ê°•í™”, ì±„ë„ ê°•í™” ì ìš©
        const enhanced = enhanceColor(baseColor, 1.2);
        const contrasted = enhanceContrast(enhanced, 1.2);
        const finalColor = enhanceSaturation(contrasted, 1.2);
        
        allColors.push({
          color: finalColor,
          frequency: cluster.length, // í´ëŸ¬ìŠ¤í„° í¬ê¸° = ì‚¬ìš© ë¹ˆë„
          cluster: cluster
        });
      }
      
      // ì‚¬ìš© ë¹ˆë„ìˆœìœ¼ë¡œ ì •ë ¬ (ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìƒ‰ìƒì´ ë¨¼ì €)
      allColors.sort((a, b) => b.frequency - a.frequency);
      
            // ì‚¬ìš© ë¹ˆë„ ê¸°ë°˜ìœ¼ë¡œ ìƒ‰ìƒ ì„ íƒ (ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìƒ‰ìƒë¶€í„°)
      const selectedColors = [];
      
      // 1. ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìƒ‰ìƒì„ ë°°ê²½ìœ¼ë¡œ ì„ íƒ
      if (allColors.length > 0) {
        selectedColors.push(allColors[0].color);
      }
      
      // 2. ë‚˜ë¨¸ì§€ ìƒ‰ìƒë“¤ì„ ë‹¤ì–‘ì„±ê³¼ ë¹ˆë„ë¥¼ ê³ ë ¤í•˜ì—¬ ì„ íƒ
      for (let i = 1; i < allColors.length && selectedColors.length < count; i++) {
        const currentColor = allColors[i].color;
        
        // ì´ë¯¸ ì„ íƒëœ ìƒ‰ìƒê³¼ ì¶©ë¶„íˆ ë‹¤ë¥¸ì§€ í™•ì¸
        const isDiverse = selectedColors.every(selected => 
          euclideanDistance([currentColor.r, currentColor.g, currentColor.b], 
                          [selected.r, selected.g, selected.b]) > 40
        );
        
        if (isDiverse) {
          selectedColors.push(currentColor);
        }
      }
      
      // 3. ë‹¤ì–‘ì„±ì´ ë¶€ì¡±í•œ ê²½ìš°, ê±°ë¦¬ ê¸°ì¤€ì„ ë‚®ì¶°ì„œ ì¶”ê°€ ì„ íƒ
      if (selectedColors.length < count) {
        for (let i = 1; i < allColors.length && selectedColors.length < count; i++) {
          const currentColor = allColors[i].color;
          
          // ë” ë‚®ì€ ê±°ë¦¬ ê¸°ì¤€ìœ¼ë¡œ í™•ì¸
          const isDiverse = selectedColors.every(selected => 
            euclideanDistance([currentColor.r, currentColor.g, currentColor.b], 
                            [selected.r, selected.g, selected.b]) > 20
          );
          
          if (isDiverse) {
            selectedColors.push(currentColor);
          }
        }
      }
      
      // 4. ìµœì¢…ì ìœ¼ë¡œ ë¶€ì¡±í•œ ê²½ìš°, ëª¨ë“  ìƒ‰ìƒ ì‚¬ìš©
      if (selectedColors.length < count) {
        for (let i = 1; i < allColors.length && selectedColors.length < count; i++) {
          const currentColor = allColors[i].color;
          if (!selectedColors.some(selected => 
            euclideanDistance([currentColor.r, currentColor.g, currentColor.b], 
                            [selected.r, selected.g, selected.b]) < 10
          )) {
            selectedColors.push(currentColor);
          }
        }
      }
      
      return selectedColors.slice(0, count);
    }

    // K-means í´ëŸ¬ìŠ¤í„°ë§ (ë‹¨ìˆœí•œ ê¸°ë³¸ ë²„ì „)
    function kMeansClustering(pixels, k) {
      // 1. ì´ˆê¸° ì¤‘ì‹¬ì ì„ ëœë¤í•˜ê²Œ ì„ íƒ
      const centroids = [];
      for (let i = 0; i < k; i++) {
        const randomIndex = Math.floor(Math.random() * pixels.length);
        centroids.push([...pixels[randomIndex]]);
      }
      
      const maxIterations = 10;
      let finalClusters = Array(k).fill().map(() => []);
      
      for (let iteration = 0; iteration < maxIterations; iteration++) {
        // 2. ê° í”½ì…€ì„ ê°€ì¥ ê°€ê¹Œìš´ ì¤‘ì‹¬ì ì— í• ë‹¹
        const clusters = Array(k).fill().map(() => []);
        
        for (const pixel of pixels) {
          let minDistance = Infinity;
          let closestCentroid = 0;
          
          for (let i = 0; i < k; i++) {
            const distance = euclideanDistance(pixel, centroids[i]);
            if (distance < minDistance) {
              minDistance = distance;
              closestCentroid = i;
            }
          }
          
          clusters[closestCentroid].push(pixel);
        }
        
        // 3. ì¤‘ì‹¬ì  ì—…ë°ì´íŠ¸ (ë‹¨ìˆœ í‰ê· )
        let centroidsChanged = false;
        for (let i = 0; i < k; i++) {
          if (clusters[i].length > 0) {
            const newCentroid = clusters[i].reduce((acc, pixel) => {
              acc[0] += pixel[0];
              acc[1] += pixel[1];
              acc[2] += pixel[2];
              return acc;
            }, [0, 0, 0]);
            
            newCentroid[0] = Math.round(newCentroid[0] / clusters[i].length);
            newCentroid[1] = Math.round(newCentroid[1] / clusters[i].length);
            newCentroid[2] = Math.round(newCentroid[2] / clusters[i].length);
            
            // ì¤‘ì‹¬ì ì´ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (euclideanDistance(newCentroid, centroids[i]) > 1) {
              centroids[i] = newCentroid;
              centroidsChanged = true;
            }
          }
        }
        
        // ìµœì¢… í´ëŸ¬ìŠ¤í„° ì €ì¥
        finalClusters = clusters;
        
        // 4. ìˆ˜ë ´ ì¡°ê±´: ì¤‘ì‹¬ì ì´ ë³€í•˜ì§€ ì•Šìœ¼ë©´ ì¢…ë£Œ
        if (!centroidsChanged) {
          break;
        }
      }
      
      return finalClusters;
    }

    // ìœ í´ë¦¬ë“œ ê±°ë¦¬ ê³„ì‚°
    function euclideanDistance(pixel1, pixel2) {
      return Math.sqrt(
        Math.pow(pixel1[0] - pixel2[0], 2) +
        Math.pow(pixel1[1] - pixel2[1], 2) +
        Math.pow(pixel1[2] - pixel2[2], 2)
      );
    }

    // ìƒ‰ìƒ ìœ„ì¹˜ ì°¾ê¸° (ì‚¬ìš© ë¹ˆë„ ê¸°ë°˜)
    function getColorPositions(img, targetColor, count = 3) {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);
      
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;
      
      const positions = [];
      
      for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
          const index = (y * canvas.width + x) * 4;
          const pixelColor = {
            r: data[index],
            g: data[index + 1],
            b: data[index + 2]
          };
          
          const distance = euclideanDistance(
            [pixelColor.r, pixelColor.g, pixelColor.b],
            [targetColor.r, targetColor.g, targetColor.b]
          );
          
          // ê±°ë¦¬ê°€ 50 ì´í•˜ì¸ í”½ì…€ë“¤ì„ ìˆ˜ì§‘
          if (distance <= 50) {
            positions.push({ x, y, distance });
          }
        }
      }
      
      // ê±°ë¦¬ìˆœìœ¼ë¡œ ì •ë ¬
      positions.sort((a, b) => a.distance - b.distance);
      
      // ì‚¬ìš© ë¹ˆë„ ê¸°ë°˜ ìœ„ì¹˜ ì„ íƒ
      const selectedPositions = [];
      
      // 1. ê°€ì¥ ë§ì´ ì‚¬ìš©ëœ ìƒ‰ìƒ(ë°°ê²½)ì˜ ê²½ìš°, ì´ë¯¸ì§€ì˜ ì¤‘ì‹¬ ë¶€ê·¼ì—ì„œ ì„ íƒ
      const isBackgroundColor = targetColor.r === 255 && targetColor.g === 255 && targetColor.b === 141; // ì˜ˆì‹œ ìƒ‰ìƒ
      
      if (isBackgroundColor && positions.length > 0) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // ì¤‘ì‹¬ ë¶€ê·¼ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ë“¤ ì„ íƒ
        const centerPositions = positions.sort((a, b) => {
          const distA = Math.sqrt(Math.pow(a.x - centerX, 2) + Math.pow(a.y - centerY, 2));
          const distB = Math.sqrt(Math.pow(b.x - centerX, 2) + Math.pow(b.y - centerY, 2));
          return distA - distB;
        });
        
        for (let i = 0; i < Math.min(count, centerPositions.length); i++) {
          selectedPositions.push(centerPositions[i]);
        }
      } else {
        // 2. ë‚˜ë¨¸ì§€ ìƒ‰ìƒë“¤ì€ ê³µê°„ì ìœ¼ë¡œ ë¶„ì‚°ëœ ìœ„ì¹˜ ì„ íƒ
        const minDistance = Math.min(canvas.width, canvas.height) / 4;
        
        for (const pos of positions) {
          let isFarEnough = true;
          
          for (const selected of selectedPositions) {
            const distance = Math.sqrt(
              Math.pow(pos.x - selected.x, 2) + Math.pow(pos.y - selected.y, 2)
            );
            if (distance < minDistance) {
              isFarEnough = false;
              break;
            }
          }
          
          if (isFarEnough) {
            selectedPositions.push(pos);
            if (selectedPositions.length >= count) break;
          }
        }
      }
      
      // ì¶©ë¶„í•œ ìœ„ì¹˜ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°, ê±°ë¦¬ ê¸°ì¤€ì„ ë‚®ì¶°ì„œ ì¶”ê°€ ì„ íƒ
      if (selectedPositions.length < count) {
        const remainingPositions = positions.filter(pos => 
          !selectedPositions.some(selected => 
            Math.sqrt(Math.pow(pos.x - selected.x, 2) + Math.pow(pos.y - selected.y, 2)) < 30
          )
        );
        
        while (selectedPositions.length < count && remainingPositions.length > 0) {
          selectedPositions.push(remainingPositions.shift());
        }
      }
      
      // ìµœì¢…ì ìœ¼ë¡œ ë¶€ì¡±í•œ ê²½ìš°, ê°€ì¥ ê°€ê¹Œìš´ ìœ„ì¹˜ë¥¼ ë°˜ë³µí•´ì„œ ì±„ì›€
      if (selectedPositions.length === 0) {
        let minDistance = Infinity;
        let closestPos = { x: 0, y: 0 };
        
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const index = (y * canvas.width + x) * 4;
            const pixelColor = {
              r: data[index],
              g: data[index + 1],
              b: data[index + 2]
            };
            
            const distance = euclideanDistance(
              [pixelColor.r, pixelColor.g, pixelColor.b],
              [targetColor.r, targetColor.g, targetColor.b]
            );
            
            if (distance < minDistance) {
              minDistance = distance;
              closestPos = { x, y };
            }
          }
        }
        
        for (let i = 0; i < count; i++) {
          selectedPositions.push({ x: closestPos.x + i * 10, y: closestPos.y + i * 10 });
        }
      }
      
      return selectedPositions.map(p => ({ x: p.x, y: p.y }));
    }

    // RGB ë§µ íŒŒì‹±
    function parseRGBMap(cornerColors) {
      return {
        topLeft: parseRGB(cornerColors.topLeft),
        topRight: parseRGB(cornerColors.topRight),
        bottomLeft: parseRGB(cornerColors.bottomLeft),
        bottomRight: parseRGB(cornerColors.bottomRight)
      };
    }

    // RGB ë¬¸ìì—´ íŒŒì‹±
    function parseRGB(rgbString) {
      const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (match) {
        return {
          r: parseInt(match[1]),
          g: parseInt(match[2]),
          b: parseInt(match[3])
        };
      }
      return { r: 0, g: 0, b: 0 };
    }

    // 5ìƒ‰ìƒ ë¸”ë Œë“œ ê·¸ë¦¬ê¸°
    function drawFiveColorBlend(ctx, width, height, avg, corners) {
      const gradient = ctx.createLinearGradient(0, 0, width, height);
      gradient.addColorStop(0, `rgb(${avg.r}, ${avg.g}, ${avg.b})`);
      gradient.addColorStop(0.25, `rgb(${corners.topLeft.r}, ${corners.topLeft.g}, ${corners.topLeft.b})`);
      gradient.addColorStop(0.5, `rgb(${corners.topRight.r}, ${corners.topRight.g}, ${corners.topRight.b})`);
      gradient.addColorStop(0.75, `rgb(${corners.bottomLeft.r}, ${corners.bottomLeft.g}, ${corners.bottomLeft.b})`);
      gradient.addColorStop(1, `rgb(${corners.bottomRight.r}, ${corners.bottomRight.g}, ${corners.bottomRight.b})`);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
    }

    // 3ìƒ‰ìƒ ìœ„ì¹˜ ë¸”ë Œë“œ ê·¸ë¦¬ê¸° (ê°•í™”ëœ ë²„ì „)
    function drawThreeColorPositionBlend(ctx, width, height, bgColor, colors, allPositions) {
      console.log('ê·¸ë¼ë””ì–¸íŠ¸ ê·¸ë¦¬ê¸° ì‹œì‘:', { width, height, bgColor, colors, allPositions });
      
      // ë°°ê²½ìƒ‰ìœ¼ë¡œ ì´ˆê¸°í™”
      ctx.fillStyle = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
      ctx.fillRect(0, 0, width, height);
      
              // ìƒ‰ìƒ ê°•í™” í•¨ìˆ˜ (ëŒ€ë¹„ í–¥ìƒ)
        function enhanceColor(color, factor = 1.2) {
        // ìƒ‰ìƒ ê°’ ê²€ì¦
        if (!color || typeof color.r !== 'number' || typeof color.g !== 'number' || typeof color.b !== 'number' ||
            isNaN(color.r) || isNaN(color.g) || isNaN(color.b)) {
          console.warn('ì˜ëª»ëœ ìƒ‰ìƒ ê°’:', color);
          return { r: 128, g: 128, b: 128 }; // ê¸°ë³¸ íšŒìƒ‰
        }
        
        // ìƒ‰ìƒ ê°•í™”
        const enhanced = {
          r: Math.min(255, Math.max(0, Math.round(color.r * factor))),
          g: Math.min(255, Math.max(0, Math.round(color.g * factor))),
          b: Math.min(255, Math.max(0, Math.round(color.b * factor)))
        };
        
        // ëŒ€ë¹„ ê°•í™” (ë°ê¸° ì°¨ì´ë¥¼ ë” í¬ê²Œ)
        const brightness = (enhanced.r * 0.299 + enhanced.g * 0.587 + enhanced.b * 0.114);
        const bgBrightness = (bgColor.r * 0.299 + bgColor.g * 0.587 + bgColor.b * 0.114);
        
        // ë°°ê²½ë³´ë‹¤ ë” ë°ê±°ë‚˜ ì–´ë‘ìš´ ìƒ‰ìœ¼ë¡œ ë§Œë“¤ê¸°
        if (brightness > bgBrightness) {
          // ë°ì€ ìƒ‰ì„ ë” ë°ê²Œ
          const boost = 1.1;
          enhanced.r = Math.min(255, Math.max(0, Math.round(enhanced.r * boost)));
          enhanced.g = Math.min(255, Math.max(0, Math.round(enhanced.g * boost)));
          enhanced.b = Math.min(255, Math.max(0, Math.round(enhanced.b * boost)));
        } else {
          // ì–´ë‘ìš´ ìƒ‰ì„ ë” ì–´ë‘¡ê²Œ
          const darken = 0.8;
          enhanced.r = Math.max(0, Math.round(enhanced.r * darken));
          enhanced.g = Math.max(0, Math.round(enhanced.g * darken));
          enhanced.b = Math.max(0, Math.round(enhanced.b * darken));
        }
        
        return enhanced;
      }
      
      // ê° ìƒ‰ìƒì˜ ëª¨ë“  ìœ„ì¹˜ì— ëŒ€í•´ ë°©ì‚¬í˜• ê·¸ë¼ë””ì–¸íŠ¸ ê·¸ë¦¬ê¸°
      colors.forEach((color, colorIndex) => {
        const positions = allPositions[colorIndex];
        
        if (positions && positions.length > 0) {
          positions.forEach((pos, posIndex) => {
            console.log(`ìƒ‰ìƒ ${colorIndex} ìœ„ì¹˜ ${posIndex}:`, color, 'ìœ„ì¹˜:', pos);
            
            const normalizedX = pos.x / 300;
            const normalizedY = pos.y / 300;
            
            // ìƒ‰ìƒ ê°•í™” (ë” ê°•í•˜ê²Œ)
            const enhancedColor = enhanceColor(color, 1.2);
            
            // ê·¸ë¼ë””ì–¸íŠ¸ ë°˜ê²½ì„ ë” í¬ê²Œ
            const gradientRadius = width * 0.9;
            
            const gradient = ctx.createRadialGradient(
              normalizedX * width, normalizedY * height, 0,
              normalizedX * width, normalizedY * height, gradientRadius
            );
            
            // ì•ŒíŒŒê°’ ì¦ê°€ ë° ì¤‘ê°„ ìŠ¤í†± ì¶”ê°€
            const alpha1 = posIndex === 0 ? 1.0 : 0.8;
            const alpha2 = posIndex === 0 ? 0.6 : 0.4;
            
            gradient.addColorStop(0, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, ${alpha1})`);
            gradient.addColorStop(0.5, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, ${alpha2})`);
            gradient.addColorStop(1, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, 0)`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            console.log(`ê·¸ë¼ë””ì–¸íŠ¸ ${colorIndex}-${posIndex} ê·¸ë¦¬ê¸° ì™„ë£Œ`);
          });
        } else {
          // ìœ„ì¹˜ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ìœ„ì¹˜ ì‚¬ìš©
          const defaultPos = { x: 150, y: 150 };
          console.log(`ìƒ‰ìƒ ${colorIndex} ê¸°ë³¸ ìœ„ì¹˜ ì‚¬ìš©:`, color, 'ìœ„ì¹˜:', defaultPos);
          
          const normalizedX = defaultPos.x / 300;
          const normalizedY = defaultPos.y / 300;
          
          const enhancedColor = enhanceColor(color, 1.2);
          const gradientRadius = width * 0.9;
          
          const gradient = ctx.createRadialGradient(
            normalizedX * width, normalizedY * height, 0,
            normalizedX * width, normalizedY * height, gradientRadius
          );
          
          gradient.addColorStop(0, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, 1.0)`);
          gradient.addColorStop(0.5, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, 0.6)`);
          gradient.addColorStop(1, `rgba(${enhancedColor.r}, ${enhancedColor.g}, ${enhancedColor.b}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, width, height);
        }
      });
      
      console.log('ê·¸ë¼ë””ì–¸íŠ¸ ê·¸ë¦¬ê¸° ì™„ë£Œ');
    }

    // ê·¸ë¼ë””ì–¸íŠ¸ ê¸°ì¤€ì  í‘œì‹œ (ì›ë³¸ ì´ë¯¸ì§€ ë¹„ìœ¨ ê³ ë ¤)
    function displayGradientPoints() {
      const gradientPoints2 = document.getElementById('gradientPoints2');
      const gradientPoints3 = document.getElementById('gradientPoints3');
      const gradientPoints4 = document.getElementById('gradientPoints4');
      const gradientPoints5 = document.getElementById('gradientPoints5');
      const gradientPoints6 = document.getElementById('gradientPoints6');
      
      // ëª¨ë“  ê·¸ë¼ë””ì–¸íŠ¸ í¬ì¸íŠ¸ ì»¨í…Œì´ë„ˆ ì´ˆê¸°í™”
      [gradientPoints2, gradientPoints3, gradientPoints4, gradientPoints5, gradientPoints6].forEach(container => {
        if (container) container.innerHTML = '';
      });
      
      if (!showGradientPoints.checked) return;
      
      // í˜„ì¬ í‘œì‹œ í¬ê¸° ê°€ì ¸ì˜¤ê¸° (ì›ë³¸ ì´ë¯¸ì§€ ê¸°ì¤€)
      const originalImage = document.getElementById('originalImage');
      if (!originalImage || !originalImage.style.width || !originalImage.style.height) return;
      
      const displayWidth = parseInt(originalImage.style.width);
      const displayHeight = parseInt(originalImage.style.height);
      
      // â‘¡ BlurHash - ì¤‘ì•™ì  í‘œì‹œ
      if (gradientPoints2) {
        const centerPoint = document.createElement('div');
        centerPoint.className = 'gradient-point';
        centerPoint.style.left = (displayWidth / 2 - 3) + 'px';
        centerPoint.style.top = (displayHeight / 2 - 3) + 'px';
        centerPoint.style.background = '#ff6b6b';
        gradientPoints2.appendChild(centerPoint);
      }
      
      // â‘¢ 4í”½ì…€ ë¸”ëŸ¬ - 4ê°œ ì½”ë„ˆì  í‘œì‹œ (10% ë§ˆì§„ ì ìš©)
      if (gradientPoints3) {
        const margin = 0.1; // 10% ë§ˆì§„
        const corners = [
          { x: displayWidth * margin, y: displayHeight * margin, color: '#ff6b6b' },
          { x: displayWidth * (1 - margin), y: displayHeight * margin, color: '#4ecdc4' },
          { x: displayWidth * margin, y: displayHeight * (1 - margin), color: '#45b7d1' },
          { x: displayWidth * (1 - margin), y: displayHeight * (1 - margin), color: '#96ceb4' }
        ];
        
        corners.forEach(corner => {
          const point = document.createElement('div');
          point.className = 'gradient-point';
          point.style.left = (corner.x - 3) + 'px';
          point.style.top = (corner.y - 3) + 'px';
          point.style.background = corner.color;
          gradientPoints3.appendChild(point);
        });
      }
      
      // â‘£ 9í”½ì…€ ë¸”ëŸ¬ - 9ê°œ ì§€ì  í‘œì‹œ
      if (gradientPoints4) {
        const ninePoints = [
          { x: displayWidth * 0.167, y: displayHeight * 0.167 },
          { x: displayWidth * 0.5, y: displayHeight * 0.167 },
          { x: displayWidth * 0.833, y: displayHeight * 0.167 },
          { x: displayWidth * 0.167, y: displayHeight * 0.5 },
          { x: displayWidth * 0.5, y: displayHeight * 0.5 },
          { x: displayWidth * 0.833, y: displayHeight * 0.5 },
          { x: displayWidth * 0.167, y: displayHeight * 0.833 },
          { x: displayWidth * 0.5, y: displayHeight * 0.833 },
          { x: displayWidth * 0.833, y: displayHeight * 0.833 }
        ];
        
        ninePoints.forEach((pos, index) => {
          const point = document.createElement('div');
          point.className = 'gradient-point';
          point.style.left = (pos.x - 3) + 'px';
          point.style.top = (pos.y - 3) + 'px';
          point.style.background = '#ff6b6b'; // í†µì¼ëœ ìƒ‰ìƒìœ¼ë¡œ í‘œì‹œ
          gradientPoints4.appendChild(point);
        });
      }
      
      // â‘¤ ëŒ€í‘œìƒ‰+ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ (í‰ê·  ë°°ê²½) - ì‹¤ì œ ì¶”ì¶œëœ ìœ„ì¹˜ í‘œì‹œ
      if (gradientPoints5 && window.lastAllPositions) {
        window.lastAllPositions.forEach((positions, colorIndex) => {
          positions.forEach((pos, posIndex) => {
            const point = document.createElement('div');
            point.className = 'gradient-point';
            // ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¥¼ í‘œì‹œ í¬ê¸°ë¡œ ë³€í™˜
            const scaledX = (pos.x / window.lastOriginalWidth) * displayWidth;
            const scaledY = (pos.y / window.lastOriginalHeight) * displayHeight;
            point.style.left = (scaledX - 3) + 'px';
            point.style.top = (scaledY - 3) + 'px';
            point.style.background = `hsl(${colorIndex * 72}, 70%, 60%)`; // ìƒ‰ìƒë³„ë¡œ ë‹¤ë¥¸ ìƒ‰ìƒ
            gradientPoints5.appendChild(point);
          });
        });
      }
      
      // â‘¥ ëŒ€í‘œìƒ‰+ìœ„ì¹˜ ê·¸ë¼ë””ì–¸íŠ¸ (ìµœë‹¤ ë¹ˆë„ ë°°ê²½) - ì‹¤ì œ ì¶”ì¶œëœ ìœ„ì¹˜ í‘œì‹œ
      if (gradientPoints6 && window.lastAllPositions2) {
        window.lastAllPositions2.forEach((positions, colorIndex) => {
          positions.forEach((pos, posIndex) => {
            const point = document.createElement('div');
            point.className = 'gradient-point';
            // ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¥¼ í‘œì‹œ í¬ê¸°ë¡œ ë³€í™˜
            const scaledX = (pos.x / window.lastOriginalWidth) * displayWidth;
            const scaledY = (pos.y / window.lastOriginalHeight) * displayHeight;
            point.style.left = (scaledX - 3) + 'px';
            point.style.top = (scaledY - 3) + 'px';
            point.style.background = `hsl(${colorIndex * 72}, 70%, 60%)`; // ìƒ‰ìƒë³„ë¡œ ë‹¤ë¥¸ ìƒ‰ìƒ
            gradientPoints6.appendChild(point);
          });
        });
      }
    }

    // í•´ì„¤ í‘œì‹œ
    function displayExplanations() {
      const explanations = [
        document.getElementById('explanation2'),
        document.getElementById('explanation3'),
        document.getElementById('explanation4'),
        document.getElementById('explanation5'),
        document.getElementById('explanation6')
      ];
      
      explanations.forEach(explanation => {
        if (explanation) {
          explanation.style.display = showExplanation.checked ? 'block' : 'none';
        }
      });
    }

    // ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    showOriginalMarkers.addEventListener('change', () => {
      if (positionMarkers1) {
        positionMarkers1.style.display = showOriginalMarkers.checked ? 'block' : 'none';
      }
    });
    
    showGradientPoints.addEventListener('change', displayGradientPoints);
    showExplanation.addEventListener('change', displayExplanations);

    // ë°ì´í„° êµ¬ì¡° ìƒì„±
    function createDataStructure(bgColor, colors, allPositions, blurHash, cornerColors) {
      const data = {
        blurHash: blurHash,
        fourColors: {
          topLeft: parseRGB(cornerColors.topLeft),
          topRight: parseRGB(cornerColors.topRight),
          bottomLeft: parseRGB(cornerColors.bottomLeft),
          bottomRight: parseRGB(cornerColors.bottomRight)
        },
        dominantColors: colors.map((color, index) => ({
          color: color,
          positions: allPositions[index] || []
        })),
        background: bgColor
      };
      
      return data;
    }

          // ë°ì´í„° í‘œì‹œ
      function displayData(data) {
        let output = '';
        
        // BlurHash
        output += `01 BlurHash: ${data.blurHash}\n\n`;
        
        // ë°°ê²½ìƒ‰
        output += `02 Background: rgb(${data.background.r}, ${data.background.g}, ${data.background.b})\n\n`;
        
        // 4ì½”ë„ˆ ìƒ‰ìƒ
        output += `03 Four Corner Colors:\n`;
        output += `   TopLeft: rgb(${data.fourColors.topLeft.r}, ${data.fourColors.topLeft.g}, ${data.fourColors.topLeft.b})\n`;
        output += `   TopRight: rgb(${data.fourColors.topRight.r}, ${data.fourColors.topRight.g}, ${data.fourColors.topRight.b})\n`;
        output += `   BottomLeft: rgb(${data.fourColors.bottomLeft.r}, ${data.fourColors.bottomLeft.g}, ${data.fourColors.bottomLeft.b})\n`;
        output += `   BottomRight: rgb(${data.fourColors.bottomRight.r}, ${data.fourColors.bottomRight.g}, ${data.fourColors.bottomRight.b})\n\n`;
        
        // ëŒ€í‘œ ìƒ‰ìƒê³¼ ìœ„ì¹˜ (ê°œì„ ëœ í‘œì‹œ)
        output += `04 Dominant Colors with Positions:\n`;
        data.dominantColors.forEach((item, index) => {
          output += `   ğŸ¨ Color${index + 1}: rgb(${item.color.r}, ${item.color.g}, ${item.color.b})\n`;
          
          // í•´ë‹¹ ìƒ‰ìƒì˜ ëª¨ë“  ìœ„ì¹˜ í‘œì‹œ
          const colorPositions = item.positions;
          if (colorPositions && colorPositions.length > 0) {
            colorPositions.forEach((pos, posIndex) => {
              output += `   ğŸ“ Position${index + 1}.${posIndex + 1}: (${pos.x}, ${pos.y})\n`;
            });
          } else {
            output += `   ğŸ“ Position${index + 1}: ìœ„ì¹˜ ì •ë³´ ì—†ìŒ\n`;
          }
          
          output += `   ğŸ’¡ ì¶”ì¶œëœ í”½ì…€: ì›ë³¸ ì´ë¯¸ì§€ì˜ í•´ë‹¹ ìœ„ì¹˜ë“¤ì—ì„œ ì¶”ì¶œ\n\n`;
        });
        
        dataContent.textContent = output;
        dataOutput.style.display = 'block';
      }
  </script>
</body>
</html>


